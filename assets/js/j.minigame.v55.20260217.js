!function(){"use strict";const t="88st_minigame_state_v1",e="88st_minigame_picks_v1",n=[{id:"dong_pwb_plus",title:"동행 파워볼",markets:[{id:"pwb_oe2",title:"파워볼 홀/짝",outcomes:[{id:"odd",label:"홀",synonyms:["홀","odd","o"]},{id:"even",label:"짝",synonyms:["짝","even","e"]}]},{id:"pwb_ou2",title:"파워볼 언더/오버",outcomes:[{id:"under",label:"언더",synonyms:["언더","under","u"]},{id:"over",label:"오버",synonyms:["오버","over","o"]}]},{id:"sum_oe",title:"일반볼(합) 홀/짝",outcomes:[{id:"odd",label:"홀",synonyms:["홀","odd","o"]},{id:"even",label:"짝",synonyms:["짝","even","e"]}]},{id:"sum_ou",title:"일반볼(합) 언더/오버",outcomes:[{id:"under",label:"언더",synonyms:["언더","under","u"]},{id:"over",label:"오버",synonyms:["오버","over","o"]}]},{id:"sum_sml",title:"일반볼(합) 대/중/소",outcomes:[{id:"big",label:"대",synonyms:["대","big","b"]},{id:"mid",label:"중",synonyms:["중","mid","m"]},{id:"small",label:"소",synonyms:["소","small","s"]}]}]},{id:"dong_kino_ladder",title:"동행 키노사다리",markets:[{id:"lr",title:"좌/우",outcomes:[{id:"left",label:"좌",synonyms:["좌","left","l"]},{id:"right",label:"우",synonyms:["우","right","r"]}]},{id:"lines",title:"3줄/4줄",outcomes:[{id:"line3",label:"3줄",synonyms:["3","3줄","3line","three"]},{id:"line4",label:"4줄",synonyms:["4","4줄","4line","four"]}]},{id:"start",title:"시작점 홀/짝",outcomes:[{id:"odd",label:"홀",synonyms:["홀","odd","o"]},{id:"even",label:"짝",synonyms:["짝","even","e"]}]}]},{id:"dong_speed_keno",title:"동행 스피드키노",markets:[{id:"keno_oe2",title:"키노 홀/짝",outcomes:[{id:"odd",label:"홀",synonyms:["홀","odd","o"]},{id:"even",label:"짝",synonyms:["짝","even","e"]}]},{id:"keno_ou2",title:"키노 언더/오버",outcomes:[{id:"under",label:"언더",synonyms:["언더","under","u"]},{id:"over",label:"오버",synonyms:["오버","over","o"]}]},{id:"keno_sml",title:"키노 합 대/중/소",outcomes:[{id:"big",label:"대",synonyms:["대","big","b"]},{id:"mid",label:"중",synonyms:["중","mid","m"]},{id:"small",label:"소",synonyms:["소","small","s"]}]}]},{id:"bpec_eth_pwb",title:"베픽 파워볼(이더)",markets:[{id:"pwb_oe2",title:"파워볼 홀/짝",outcomes:[{id:"odd",label:"홀",synonyms:["홀","odd","o"]},{id:"even",label:"짝",synonyms:["짝","even","e"]}]},{id:"pwb_ou2",title:"파워볼 언더/오버",outcomes:[{id:"under",label:"언더",synonyms:["언더","under","u"]},{id:"over",label:"오버",synonyms:["오버","over","o"]}]},{id:"sum_oe",title:"일반볼(합) 홀/짝",outcomes:[{id:"odd",label:"홀",synonyms:["홀","odd","o"]},{id:"even",label:"짝",synonyms:["짝","even","e"]}]},{id:"sum_ou",title:"일반볼(합) 언더/오버",outcomes:[{id:"under",label:"언더",synonyms:["언더","under","u"]},{id:"over",label:"오버",synonyms:["오버","over","o"]}]},{id:"sum_sml",title:"일반볼(합) 대/중/소",outcomes:[{id:"big",label:"대",synonyms:["대","big","b"]},{id:"mid",label:"중",synonyms:["중","mid","m"]},{id:"small",label:"소",synonyms:["소","small","s"]}]}]},{id:"bpec_eth_ladder",title:"베픽 사다리(이더)",markets:[{id:"lr",title:"좌/우",outcomes:[{id:"left",label:"좌",synonyms:["좌","left","l"]},{id:"right",label:"우",synonyms:["우","right","r"]}]},{id:"lines",title:"3줄/4줄",outcomes:[{id:"line3",label:"3줄",synonyms:["3","3줄","3line","three"]},{id:"line4",label:"4줄",synonyms:["4","4줄","4line","four"]}]},{id:"start",title:"시작점 홀/짝",outcomes:[{id:"odd",label:"홀",synonyms:["홀","odd","o"]},{id:"even",label:"짝",synonyms:["짝","even","e"]}]}]},{id:"eos_pwb_5m",title:"EOS 파워볼 5분",markets:[{id:"pwb_oe2",title:"파워볼 홀/짝",outcomes:[{id:"odd",label:"홀",synonyms:["홀","odd","o"]},{id:"even",label:"짝",synonyms:["짝","even","e"]}]},{id:"pwb_ou2",title:"파워볼 언더/오버",outcomes:[{id:"under",label:"언더",synonyms:["언더","under","u"]},{id:"over",label:"오버",synonyms:["오버","over","o"]}]},{id:"sum_oe",title:"일반볼(합) 홀/짝",outcomes:[{id:"odd",label:"홀",synonyms:["홀","odd","o"]},{id:"even",label:"짝",synonyms:["짝","even","e"]}]},{id:"sum_ou",title:"일반볼(합) 언더/오버",outcomes:[{id:"under",label:"언더",synonyms:["언더","under","u"]},{id:"over",label:"오버",synonyms:["오버","over","o"]}]},{id:"sum_sml",title:"일반볼(합) 대/중/소",outcomes:[{id:"big",label:"대",synonyms:["대","big","b"]},{id:"mid",label:"중",synonyms:["중","mid","m"]},{id:"small",label:"소",synonyms:["소","small","s"]}]}]},{id:"bogle_pwb",title:"보글 파워볼",markets:[{id:"pwb_oe2",title:"파워볼 홀/짝",outcomes:[{id:"odd",label:"홀",synonyms:["홀","odd","o"]},{id:"even",label:"짝",synonyms:["짝","even","e"]}]},{id:"pwb_ou2",title:"파워볼 언더/오버",outcomes:[{id:"under",label:"언더",synonyms:["언더","under","u"]},{id:"over",label:"오버",synonyms:["오버","over","o"]}]},{id:"sum_oe",title:"일반볼(합) 홀/짝",outcomes:[{id:"odd",label:"홀",synonyms:["홀","odd","o"]},{id:"even",label:"짝",synonyms:["짝","even","e"]}]},{id:"sum_ou",title:"일반볼(합) 언더/오버",outcomes:[{id:"under",label:"언더",synonyms:["언더","under","u"]},{id:"over",label:"오버",synonyms:["오버","over","o"]}]},{id:"sum_sml",title:"일반볼(합) 대/중/소",outcomes:[{id:"big",label:"대",synonyms:["대","big","b"]},{id:"mid",label:"중",synonyms:["중","mid","m"]},{id:"small",label:"소",synonyms:["소","small","s"]}]}]},{id:"bogle_ladder_3m",title:"보글 사다리 3분",markets:[{id:"lr",title:"좌/우",outcomes:[{id:"left",label:"좌",synonyms:["좌","left","l"]},{id:"right",label:"우",synonyms:["우","right","r"]}]},{id:"lines",title:"3줄/4줄",outcomes:[{id:"line3",label:"3줄",synonyms:["3","3줄","3line","three"]},{id:"line4",label:"4줄",synonyms:["4","4줄","4line","four"]}]},{id:"start",title:"시작점 홀/짝",outcomes:[{id:"odd",label:"홀",synonyms:["홀","odd","o"]},{id:"even",label:"짝",synonyms:["짝","even","e"]}]}]}],$=t=>document.getElementById(t);function fmt(t,e=2){return Number.isFinite(t)?t.toLocaleString(void 0,{maximumFractionDigits:e}):"—"}function pct(t,e=2){return Number.isFinite(t)?(100*t).toLocaleString(void 0,{maximumFractionDigits:e})+"%":"—"}function clamp(t,e,n){const s=Number(t);return Number.isFinite(s)?Math.max(e,Math.min(n,s)):e}function saveState(e){try{localStorage.setItem(t,JSON.stringify(e))}catch(t){}}function loadPicks(){try{const t=localStorage.getItem(e);if(!t)return[];const n=JSON.parse(t);return Array.isArray(n)?n:[]}catch(t){return[]}}function savePicks(t){try{localStorage.setItem(e,JSON.stringify(t||[]))}catch(t){}}function defaultState(){const t=n[0],e=t.markets[0],s={},o={};return e.outcomes.forEach(t=>{s[t.id]=1.95,o[t.id]=""}),{game:t.id,market:e.id,stake:1e4,stopLoss:0,streakWarn:7,odds:s,probs:o,autoApply:!0,recentN:6,historyText:""}}let s=function loadState(){try{const e=localStorage.getItem(t);return e?JSON.parse(e):null}catch(t){return null}}()||defaultState();function getGame(t){return n.find(e=>e.id===t)||n[0]}function getMarket(t,e){return t.markets.find(t=>t.id===e)||t.markets[0]}function ensureMarketState(t){s.odds=s.odds||{},s.probs=s.probs||{},t.outcomes.forEach(t=>{null==s.odds[t.id]&&(s.odds[t.id]=1.95),null==s.probs[t.id]&&(s.probs[t.id]="")});const e=new Set(t.outcomes.map(t=>t.id));for(const t of Object.keys(s.odds))e.has(t)||delete s.odds[t];for(const t of Object.keys(s.probs))e.has(t)||delete s.probs[t]}function renderOutcomes(){const t=getMarket(getGame(s.game),s.market);ensureMarketState(t);const e=$("mgInputBody");e&&(e.innerHTML=t.outcomes.map(t=>{const e=s.odds[t.id],n=s.probs[t.id];return`\n        <tr data-out="${t.id}">\n          <td><span class="mg-pill">${t.label}</span></td>\n          <td><input class="mg-in ${Number.isFinite(e)&&e>1?"":"is-bad"}" inputmode="decimal" data-k="odds" value="${e??""}"/></td>\n          <td><input class="mg-in" inputmode="decimal" data-k="prob" placeholder="자동" value="${n??""}" readonly/></td>\n          \n        </tr>\n      `}).join(""),e.querySelectorAll("input.mg-in").forEach(t=>{t.addEventListener("input",debounce(()=>{const e=t.closest("tr");if(!e)return;const n=e.getAttribute("data-out"),o=t.getAttribute("data-k");"odds"===o&&function(){const e=toNum(t.value);s.odds[n]=e,t.classList.toggle("is-bad",!(Number.isFinite(e)&&e>1))}(),"prob"===o&&(s.probs[n]=t.value),saveState(s),calcAndRender()},80))}))}s.recentN||(s.recentN=6),null==s.autoApply&&(s.autoApply=!0),null==s.stopLoss&&(s.stopLoss=0),null==s.streakWarn&&(s.streakWarn=7);let o=[];function setHistoryText(t,e=!0){const n=$("mgHistory"),a=String(s.historyText||""),i=String(t||"");e&&o.push(a),s.historyText=i,n&&(n.value=i),saveState(s)}function tokensFromHistory(t){return String(t||"").trim().split(/[\s,|]+/).map(t=>t.trim()).filter(Boolean)}function renderQuickPanel(){const t=$("mgQuickChips");if(!t)return;const e=getMarket(getGame(s.game),s.market);t.innerHTML=e.outcomes.map(t=>`<button class="mg-chip" type="button" data-out="${t.id}">${t.label}</button>`).join(""),t.querySelectorAll("button[data-out]").forEach(t=>{t.addEventListener("click",()=>{const n=t.getAttribute("data-out"),o=e.outcomes.find(t=>t.id===n);if(!o)return;setHistoryText(tokensFromHistory(s.historyText).concat([o.label]).join(" "),!0),$("mgAutoApply")?.checked&&applyFreqNow(!0)})});const n=$("mgUndo");n&&(n.onclick=()=>{const t=o.pop();if(null==t)return toast("되돌릴 내용이 없습니다");setHistoryText(t,!1),$("mgAutoApply")?.checked&&String(s.historyText||"").trim()&&applyFreqNow(!0)});const a=$("mgBackspace");a&&(a.onclick=()=>{const t=tokensFromHistory(s.historyText);if(!t.length)return toast("삭제할 결과가 없습니다");if(o.push(String(s.historyText||"")),t.pop(),setHistoryText(t.join(" "),!1),!t.length){return getMarket(getGame(s.game),s.market).outcomes.forEach(t=>s.probs[t.id]=""),s._lastSeq=[],s._lastHistoryN=0,saveState(s),renderOutcomes(),calcAndRender(),void updateRiskBox()}$("mgAutoApply")?.checked?applyFreqNow(!0):updateRiskBox()});const i=$("mgQuickClear");i&&(i.onclick=()=>{o.push(String(s.historyText||"")),setHistoryText("",!1);getMarket(getGame(s.game),s.market).outcomes.forEach(t=>s.probs[t.id]=""),s._lastSeq=[],s._lastHistoryN=0,saveState(s),renderOutcomes(),calcAndRender(),updateRiskBox(),toast("빠른 입력 초기화")})}function applyFreqNow(t=!1){const e=$("mgHistory"),n=(e?e.value:s.historyText)||"",o=getMarket(getGame(s.game),s.market),a=function computeFreqRecent(t,e,n){const s=String(t||"").trim();if(!s)return{total:0,counts:{},probs:{}};const o=s.split(/[\s,|]+/).map(t=>t.trim()).filter(Boolean),a=[];for(const t of o){const n=mapTokenToOutcome(t,e);n&&a.push(n)}if(!a.length)return{total:0,counts:{},probs:{}};const i=clamp(parseInt(n||6,10)||6,1,20),r=a.slice(-i),c={};r.forEach(t=>{c[t]=(c[t]||0)+1});const l={};return e.outcomes.forEach(t=>{l[t.id]=(c[t.id]||0)/r.length}),{total:r.length,counts:c,probs:l,seq:r}}(n,o,s.recentN);return a.total?(o.outcomes.forEach(t=>{const e=a.probs[t.id];Number.isFinite(e)&&(s.probs[t.id]=String((100*e).toFixed(2)))}),s.historyText=n,s._lastSeq=a.seq,s._lastHistoryN=a.total,saveState(s),renderOutcomes(),calcAndRender(),function renderProInsights(t,e){const n=$("mgProInsights");if(!n)return;const o=e&&Array.isArray(e.seq)?e.seq:[],a=o.length,i=Math.min(3,a),r=Math.min(10,a),c=Math.min(s.recentN||6,a),win=t=>t?o.slice(-t):[],l=win(i),m=win(r),d=win(c);function pct(t){return(100*t).toFixed(1)+"%"}function entropy(t){let e=0,n=0;for(const s of t)s>0&&(e+=-s*Math.log(s),n++);const s=n>1?Math.log(n):1;return s?e/s:0}function countsOf(e){const n={};t.outcomes.forEach(t=>{n[t.id]=0});for(const t of e)null!=n[t]&&n[t]++;return n}function probsFromCounts(e,n){return t.outcomes.map(t=>n?e[t.id]/n:0)}const u=countsOf(o),p=countsOf(l),g=countsOf(m),v=countsOf(d),b=probsFromCounts(u,a),h=probsFromCounts(p,i),k=probsFromCounts(g,r),f=probsFromCounts(v,c);let y=null,N=0,S=0;if(a>=2)for(let t=1;t<a;t++)o[t]!==o[t-1]&&S++;if(a>=1){y=o[a-1],N=1;for(let t=a-2;t>=0&&o[t]===y;t--)N++}const x=a>=2?S/(a-1):0;function maxDelta(e,n){let s=0;for(let o=0;o<t.outcomes.length;o++)s=Math.max(s,Math.abs(e[o]-n[o]));return s}const M=maxDelta(f,b),T=(maxDelta(h,b),maxDelta(k,b));function maxZ(e,n){if(!a||!n)return 0;let s=0;for(let o=0;o<t.outcomes.length;o++){const t=b[o],a=e[o];if(t<=0||t>=1)continue;const i=Math.sqrt(t*(1-t)/Math.max(n,1));if(i<=0)continue;const r=Math.abs((a-t)/i);r>s&&(s=r)}return s}const H=maxZ(h,i),F=maxZ(k,r),P=maxZ(f,c),L=Math.max(H,F,P);function biasLevel(t){return{zStrong:t>=10?2:t>=6?2.2:2.6,zMid:t>=10?1.5:t>=6?1.7:2}}const A=biasLevel(Math.max(r,c)),_=Math.max(T,M)>=.25&&L>=A.zStrong&&a>=10,E=!_&&Math.max(T,M)>=.15&&L>=A.zMid&&a>=6,O=_?"강한 편향":E?"편향":"보통",w=2===t.outcomes.length?Math.round(100*x):Math.round(100*entropy(f.length?f:b)),q=w>=70?"변동 큼":w>=40?"보통":"안정";let C=0;for(let t=1;t<f.length;t++)f[t]>f[C]&&(C=t);const R=t.outcomes[C],B=f[C],I=_&&a>=10&&(N>=3&&L>=Math.max(A.zStrong,2.2)||Math.max(T,M)>=(a>=20?.28:.33)&&L>=A.zStrong);n.innerHTML="";const j=[{k:`최근 ${c||0}회 최다`,v:R?`${R.label} · ${pct(B)}`:"데이터 없음",s:a?`최근 ${i||0}/${r||0}/${a} 비교 가능`:"최근 결과를 붙여넣어주세요",badge:O},{k:"연속(스트릭)",v:y?`${labelOf(y,t)} ${N}연속`:"데이터 없음",s:a>=2?`전환율 ${Math.round(100*x)}% (전환↑ = 패턴 난이도↑)`:"표본이 부족합니다",badge:q},{k:"편향 점수",v:a?`Δ ${pct(Math.max(T,M))} · z ${L.toFixed(2)}`:"데이터 없음",s:"최근 구간이 전체 평균과 얼마나 다른지(표본수에 따라 자동 보정)",badge:O},{k:"변동성 점수",v:`${w}/100`,s:2===t.outcomes.length?"전환율 기반":"엔트로피 기반",badge:q}],z=document.createElement("div");z.className="mg-pro-grid",j.forEach(t=>{const e=document.createElement("div");e.className="mg-pro-card",e.innerHTML=`\n        <div class="mg-pro-k">${escapeHtml(t.k)}</div>\n        <div class="mg-pro-v">${escapeHtml(t.v)}</div>\n        <div class="mg-pro-s"><span class="mg-pro-badge">${escapeHtml(t.badge)}</span> ${escapeHtml(t.s)}</div>\n      `,z.appendChild(e)}),n.appendChild(z);const G=document.createElement("div");G.className="mg-pro-compare";const D=t.outcomes.map((t,e)=>{const n=i?h[e]-b[e]:0,s=r?k[e]-b[e]:0;return`\n        <tr>\n          <td class="mg-pro-td-out">${escapeHtml(t.label)}</td>\n          <td>${i?pct(h[e]):"-"}</td>\n          <td>${r?pct(k[e]):"-"}</td>\n          <td>${a?pct(b[e]):"-"}</td>\n          <td class="${n>=0?"mg-pro-pos":"mg-pro-neg"}">${i?(n>=0?"+":"")+pct(Math.abs(n)):"-"}</td>\n          <td class="${s>=0?"mg-pro-pos":"mg-pro-neg"}">${r?(s>=0?"+":"")+pct(Math.abs(s)):"-"}</td>\n        </tr>\n      `}).join("");G.innerHTML=`\n      <div class="mg-pro-compare-head">\n        <div class="mg-pro-compare-title">최근 3 vs 최근 10 vs 전체 비교</div>\n        <div class="mg-pro-compare-sub">표본: 최근3(${i}) · 최근10(${r}) · 전체(${a})</div>\n      </div>\n      <div class="mg-pro-table-wrap">\n        <table class="mg-pro-table">\n          <thead>\n            <tr>\n              <th>결과</th>\n              <th>최근3</th>\n              <th>최근10</th>\n              <th>전체</th>\n              <th>Δ3-전체</th>\n              <th>Δ10-전체</th>\n            </tr>\n          </thead>\n          <tbody>\n            ${D||'<tr><td colspan="6" style="text-align:center;opacity:.7;">최근 결과를 붙여넣어 주세요</td></tr>'}\n          </tbody>\n        </table>\n      </div>\n      <div class="mg-pro-foot">Δ는 “최근 구간 − 전체 평균”의 차이입니다. (의미 해석은 표본수에 크게 좌우됨)</div>\n    `,n.appendChild(G);const W=document.createElement("div");W.className="mg-pro-trend";const Q=t.outcomes.map((t,e)=>{const n=i?h[e]-b[e]:0,s=r?k[e]-b[e]:0,o=0===n?0:n>0?1:-1,c=0===s?0:s>0?1:-1;let l="→";1===o&&1===c?l="↑":-1===o&&-1===c?l="↓":0===o&&0!==c?l=c>0?"↑":"↓":0===c&&0!==o?l=o>0?"↑":"↓":0!==o&&0!==c&&o!==c&&(l="↕");const m=Math.max(Math.abs(n),Math.abs(s)),d="↑"===l?"mg-pro-chip-up":"↓"===l?"mg-pro-chip-down":"mg-pro-chip-flat",u=a?`Δmax ${pct(m)}`:"";return`<div class="mg-pro-chip ${d}"><span class="mg-pro-chip-a">${l}</span><span class="mg-pro-chip-l">${escapeHtml(t.label)}</span><span class="mg-pro-chip-s">${escapeHtml(u)}</span></div>`}).join("");W.innerHTML=`\n      <div class="mg-pro-sec-head">\n        <div class="mg-pro-sec-title">추세 한눈에</div>\n        <div class="mg-pro-sec-sub">최근3/최근10이 전체 대비 같은 방향이면 ↑/↓, 엇갈리면 ↕</div>\n      </div>\n      <div class="mg-pro-chip-row">${Q||""}</div>\n    `,n.appendChild(W);const J=document.createElement("div");J.className="mg-pro-trans";const Z=4;function buildTrans(t){const e=t.length,n=[];if(e<3)return n;for(let s=1;s<e;s++){const e=t[s-1];let o=1;for(let n=s-2;n>=0&&t[n]===e&&o<Z;n--)o++;const a=t[s];n.push({k:o,prev:e,next:a})}const s={};for(const t of n){const e=`${t.k}|${t.prev}`;s[e]=s[e]||{k:t.k,prev:t.prev,total:0,nextCounts:{}},s[e].total++,s[e].nextCounts[t.next]=(s[e].nextCounts[t.next]||0)+1}return Object.values(s).sort((t,e)=>t.k-e.k)}function renderTransBlock(e,n){const s=buildTrans(n);if(!s.length)return'<div class="mg-pro-trans-empty">표본이 부족합니다</div>';const o=2===t.outcomes.length,a=s.map(e=>{const n=`${labelOf(e.prev,t)} ${e.k}연속 후`;if(o){const t=e.nextCounts[e.prev]||0,s=e.total-t,o=t/e.total,a=s/e.total;return`\n            <tr>\n              <td>${escapeHtml(n)}</td>\n              <td>${pct(o)}</td>\n              <td>${pct(a)}</td>\n              <td class="mg-pro-td-n">${e.total}</td>\n            </tr>\n          `}{const s=Object.entries(e.nextCounts).sort((t,e)=>e[1]-t[1]).slice(0,2).map(([n,s])=>`${labelOf(n,t)} ${pct(s/e.total)}`).join(" · ");return`\n            <tr>\n              <td>${escapeHtml(n)}</td>\n              <td colspan="2">${escapeHtml(s||"-")}</td>\n              <td class="mg-pro-td-n">${e.total}</td>\n            </tr>\n          `}}).join(""),i=2===t.outcomes.length?"<tr><th>조건</th><th>다음이 동일</th><th>다음이 전환</th><th>표본</th></tr>":'<tr><th>조건</th><th colspan="2">다음 결과 상위</th><th>표본</th></tr>';return`\n        <div class="mg-pro-trans-block">\n          <div class="mg-pro-trans-title">${escapeHtml(e)}</div>\n          <div class="mg-pro-table-wrap">\n            <table class="mg-pro-table mg-pro-table-sm">\n              <thead>${i}</thead>\n              <tbody>${a}</tbody>\n            </table>\n          </div>\n        </div>\n      `}J.innerHTML=`\n      <div class="mg-pro-sec-head">\n        <div class="mg-pro-sec-title">연속 후 전환율</div>\n        <div class="mg-pro-sec-sub">베픽에서 많이 보는 “몇 연속 뒤 바뀜/유지 비율” (예측 아님)</div>\n      </div>\n      <div class="mg-pro-trans-grid">\n        ${renderTransBlock("최근10 기준",m)}\n        ${renderTransBlock("전체 기준",o)}\n      </div>\n    `,n.appendChild(J);const V=document.createElement("div");V.className="mg-pro-confidence";const U=Math.max(2,t.outcomes.length),Y=a/(U/2);let K=Math.round(clamp(Y/30*100,0,100));a<6?K=Math.min(K,25):a<10&&(K=Math.min(K,40));const X=K>=75?"높음":K>=45?"보통":"낮음";V.innerHTML=`\n      <div class="mg-pro-sec-head">\n        <div class="mg-pro-sec-title">표본 신뢰도</div>\n        <div class="mg-pro-sec-sub">붙여넣은 결과(표본수)에 따른 해석 신뢰도(0~100)</div>\n      </div>\n      <div class="mg-pro-conf-row">\n        <div class="mg-pro-conf-bar" aria-label="confidence">\n          <div class="mg-pro-conf-fill" style="width:${K}%;"></div>\n        </div>\n        <div class="mg-pro-conf-meta">\n          <div class="mg-pro-conf-score">${K}/100</div>\n          <div class="mg-pro-conf-label"><span class="mg-pro-badge">${escapeHtml(X)}</span> 전체 ${a}개 · 결과 ${U}개</div>\n        </div>\n      </div>\n    `,n.appendChild(V);const tt=document.createElement("div");tt.className="mg-pro-warn",tt.setAttribute("role","note"),tt.innerHTML=I?"<b>평균회귀 주의</b> 최근 구간 편향이 강합니다(Δ/ z 기준). 이런 구간에서는 ‘평균에 가까워지는 움직임’이 자주 관찰되지만, <b>예측/보장은 아닙니다.</b> 표본을 늘려 확인하세요.":"<b>해석 팁</b> Δ가 크더라도 표본이 적으면 우연일 수 있습니다. 최근10/전체를 함께 보고 “지속되는 편향인지” 먼저 확인하세요.",n.appendChild(tt)}(o,a),updateRiskBox(),t||toast(`최근 ${a.total}개 → 확률 반영 완료`),a):(t||toast("매핑 가능한 결과가 없습니다. (예: 홀 짝 홀 / 좌 우 좌)"),updateRiskBox(),null)}function updateRiskBox(){
  const box = $("mgRisk");
  if(!box) return;

  const game = getGame(s.game);
  const market = getMarket(game, s.market);
  const outs = (market && market.outcomes) ? market.outcomes : [];
  const k = outs.length || 0;

  const seq = Array.isArray(s._lastSeq) ? s._lastSeq.slice() : [];
  const totalN = seq.length;

  // Session controls
  const stopLoss = Number(s.stopLoss||0);
  const streakWarn = Math.max(3, parseInt(s.streakWarn,10)||7);
  const sesTxt = stopLoss>0 ? `손실 한도 ${fmt(stopLoss,0)}원` : "손실 한도 꺼짐";

  // Defaults
  let score = 92;
  const tags = [];
  const warns = [];
  const recos = [];

  // Helper
  const labelOfId = (id)=> labelOf(id, market);
  const clampNum = (x,a,b)=>Math.max(a,Math.min(b,x));

  // Empty / small sample
  if(!totalN){
    tags.push({t:"표본 없음", cls:"warn"});
    warns.push("최근 결과가 비어있습니다. 결과를 붙여넣거나 빠른 입력을 사용하세요.");
    score -= 18;
  }else if(totalN < 6){
    tags.push({t:`표본 부족 ${totalN}`, cls:"warn"});
    warns.push(`표본이 ${totalN}개로 너무 적습니다. 최소 10~20개 이상을 권장합니다.`);
    score -= 14;
  }

  // Window selection (risk uses larger context than EV)
  const win = Math.max(4, Math.min(totalN, Math.max(10, Math.min(20, parseInt(s.recentN,10)||6))));
  const wseq = seq.slice(-win);

  // Counts
  const count = {};
  outs.forEach(o=>count[o.id]=0);
  wseq.forEach(x=>{ if(count[x]!=null) count[x]++; });

  // Streak
  let streakId = totalN ? seq[totalN-1] : null;
  let streak = 0;
  if(streakId){
    streak = 1;
    for(let i=totalN-2;i>=0 && seq[i]===streakId;i--) streak++;
  }
  const softStreak = Math.max(4, Math.min(6, streakWarn-2));
  const hardStreakHit = streak >= streakWarn;
  const softStreakHit = !hardStreakHit && streak >= softStreak;
  if(hardStreakHit){
    tags.push({t:`연속 위험 ${labelOfId(streakId)} x${streak}`, cls:"bad"});
    warns.push(`${labelOfId(streakId)}가 ${streak}연속입니다. 추격/역배 접근 금지(과열 구간).`);
    score -= 16;
  }else if(softStreakHit){
    tags.push({t:`연속 주의 ${labelOfId(streakId)} x${streak}`, cls:"warn"});
    warns.push(`${labelOfId(streakId)} 연속이 길어지고 있습니다(${streak}). 스테이크/횟수 축소 권장.`);
    score -= 8;
  }

  // Deviation (z-score vs uniform expectation)
  let devMax = 0;
  let devKey = null;
  let devTier = 0; // 0 none, 1 mild, 2 strong, 3 severe
  if(k >= 2 && win >= 6){
    const p0 = 1/k;
    const sd = Math.sqrt(win * p0 * (1-p0));
    if(sd>0){
      for(const o of outs){
        const z = Math.abs((count[o.id] - win*p0) / sd);
        if(z > devMax){ devMax = z; devKey = o.id; }
      }
    }
    if(devMax >= 3.0) devTier = 3;
    else if(devMax >= 2.4) devTier = 2;
    else if(devMax >= 1.8) devTier = 1;

    if(devTier){
      const dLbl = devKey ? labelOfId(devKey) : "특정 결과";
      const tTxt = devTier===3 ? "편차 매우 강함" : devTier===2 ? "편차 강함" : "편차 감지";
      const cls = devTier>=2 ? "bad" : "warn";
      tags.push({t:`${tTxt} z≈${devMax.toFixed(1)} (${dLbl})`, cls});
      warns.push(`${dLbl} 쏠림이 최근 ${win}구간에서 뚜렷합니다(z≈${devMax.toFixed(1)}). 평균회귀 기대만으로 접근 금지.`);
      score -= (devTier===3?22:devTier===2?16:10);
    }
  }

  // Sudden shift (recent 6 vs prev 6)
  if(totalN >= 12 && k >= 2){
    const w = 6;
    const recent = seq.slice(-w);
    const prev = seq.slice(-2*w, -w);
    const rc = {}; const pc = {};
    outs.forEach(o=>{rc[o.id]=0; pc[o.id]=0;});
    recent.forEach(x=>{ if(rc[x]!=null) rc[x]++; });
    prev.forEach(x=>{ if(pc[x]!=null) pc[x]++; });
    let rMax=0, pMax=0, rKey=null, pKey=null;
    outs.forEach(o=>{
      const rp = rc[o.id]/w;
      const pp = pc[o.id]/w;
      if(rp>rMax){rMax=rp; rKey=o.id;}
      if(pp>pMax){pMax=pp; pKey=o.id;}
    });
    const d = rMax - pMax;
    if(Math.abs(d) >= 0.30){
      tags.push({t:`급변 Δ${(d>=0?'+':'')}${Math.round(d*100)}%p`, cls:"bad"});
      warns.push(`최근 6구간 분포가 이전 6구간 대비 급격히 변했습니다(급변).`);
      if(rKey && pKey && rKey!==pKey) warns.push(`이전 우세: ${labelOfId(pKey)} → 최근 우세: ${labelOfId(rKey)}`);
      score -= 14;
    }else if(Math.abs(d) >= 0.20){
      tags.push({t:`변화 Δ${(d>=0?'+':'')}${Math.round(d*100)}%p`, cls:"warn"});
      warns.push(`최근 6구간 분포 변화가 큽니다(주의).`);
      score -= 7;
    }
  }

  // Switch rate / alternation for 2-way
  if(k === 2 && win >= 10){
    let sw = 0;
    for(let i=1;i<wseq.length;i++) if(wseq[i]!==wseq[i-1]) sw++;
    const trans = (wseq.length>=2) ? sw/(wseq.length-1) : 0;

    if(trans >= 0.90){
      tags.push({t:`교대 과다 ${(trans*100).toFixed(0)}%`, cls:"bad"});
      warns.push("교대가 극단적으로 잦습니다(노이즈/변동성↑). '패턴 추종' 체감 난이도 급상승.");
      score -= 12;
    }else if(trans >= 0.80){
      tags.push({t:`교대 많음 ${(trans*100).toFixed(0)}%`, cls:"warn"});
      warns.push("교대가 잦습니다. 과감한 추격/배팅 증액은 피하세요.");
      score -= 7;
    }else if(trans <= 0.15){
      tags.push({t:`교대 부족 ${(trans*100).toFixed(0)}%`, cls:"bad"});
      warns.push("교대가 거의 없습니다(연속 지속 위험). '반대'식 접근은 특히 위험합니다.");
      score -= 12;
    }else if(trans <= 0.25){
      tags.push({t:`교대 적음 ${(trans*100).toFixed(0)}%`, cls:"warn"});
      warns.push("교대가 적어 연속이 길게 이어질 수 있습니다.");
      score -= 6;
    }
  }

  // 3-way spike hint ("타이 급증" 유사: 특정 결과가 단기간 과도)
  if(k === 3 && totalN >= 9){
    const recent = seq.slice(-6);
    const rc = {}; outs.forEach(o=>rc[o.id]=0);
    recent.forEach(x=>{ if(rc[x]!=null) rc[x]++; });
    const max = Math.max(...Object.values(rc));
    if(max >= 5){
      const key = Object.keys(rc).find(id=>rc[id]===max);
      tags.push({t:`특정 결과 급증 (${labelOfId(key)})`, cls:"bad"});
      warns.push(`최근 6구간에서 ${labelOfId(key)}가 ${max}/6로 급증했습니다. 과열 구간 가능성이 큽니다.`);
      score -= 14;
    }else if(max === 4){
      const key = Object.keys(rc).find(id=>rc[id]===max);
      tags.push({t:`특정 결과 집중 (${labelOfId(key)})`, cls:"warn"});
      warns.push(`최근 6구간에서 ${labelOfId(key)} 집중이 보입니다(${max}/6).`);
      score -= 7;
    }
  }

  // Margin impact
  let margin = NaN;
  try{ margin = calc().margin; }catch(e){}
  if(Number.isFinite(margin)){
    const mPct = margin*100;
    if(margin < 0){
      tags.push({t:"배당 이상치", cls:"bad"});
      warns.push("마진이 음수로 계산됩니다. 배당 입력을 다시 확인하세요.");
      score -= 22;
    }else if(mPct >= 10){
      tags.push({t:`마진 매우 높음 ${mPct.toFixed(1)}%`, cls:"bad"});
      warns.push(`마진이 매우 높습니다(${mPct.toFixed(1)}%). 장기적으로 불리합니다.`);
      score -= 18;
    }else if(mPct >= 7.5){
      tags.push({t:`마진↑ ${mPct.toFixed(1)}%`, cls:"warn"});
      warns.push(`마진이 높습니다(${mPct.toFixed(1)}%). EV/공정배당을 재확인하세요.`);
      score -= 12;
    }else if(mPct >= 5.5){
      tags.push({t:`마진 ${mPct.toFixed(1)}%`, cls:"warn"});
      score -= 6;
    }else{
      tags.push({t:`마진 ${mPct.toFixed(1)}%`, cls:"good"});
    }
  }

  // Combo: overheat
  if((devTier >= 2 && (hardStreakHit || softStreakHit)) || (devTier >= 2 && tags.some(x=>String(x.t||"").includes("교대")))){
    tags.push({t:"과열(연속+편차)", cls:"bad"});
    warns.push("연속/편차가 동시에 강합니다. '역배/추격'을 특히 피하세요.");
    score -= 10;
  }

  score = Math.max(0, Math.min(100, Math.round(score)));
  const level = score >= 85 ? "양호" : score >= 70 ? "보통" : score >= 55 ? "주의" : "위험";

  const avoid = (score < 55) || devTier >= 2 || hardStreakHit;
  if(avoid) tags.unshift({t:"회피", cls:"bad"});

  if(!warns.length) warns.push("특이 경고 없음. 그래도 손절/한도는 꼭 지키세요.");

  if(avoid){
    recos.push("이 구간은 PASS(관망) 또는 스테이크 다운을 우선 권장합니다.");
  }else{
    recos.push("경고 태그가 있으면 베팅 단위/횟수를 줄이고, 표본을 더 모아 확인하세요.");
  }
  recos.push("연속/편차 경고가 해제될 때까지 ‘한 방 역배’식 추격은 금지.");

  const tagHtml = tags.map(x=>`<span class=\"mg-pill ${escapeHtml(x.cls)}\">${escapeHtml(x.t)}<\/span>`).join("");
  const warnHtml = warns.map(x=>`<li>${escapeHtml(x)}<\/li>`).join("");
  const recoHtml = recos.map(x=>`<li>${escapeHtml(x)}<\/li>`).join("");

  // Next outcome probabilities (recentN frequency + smoothing)
  const predN = Math.max(3, Math.min(totalN, clamp(parseInt(s.recentN,10)||6, 1, 20)));
  const pseq = seq.slice(-predN);
  const pcount = {};
  outs.forEach(o=>pcount[o.id]=0);
  pseq.forEach(x=>{ if(pcount[x]!=null) pcount[x]++; });

  const priorW = Math.max(4, Math.min(10, (k||2)*2)); // pseudo sample size
  const predArr = (totalN && k) ? outs.map(o=>{
    const p = (pcount[o.id] + priorW*(1/k)) / (predN + priorW);
    return { id:o.id, label:o.label, p };
  }) : [];
  predArr.sort((a,b)=>b.p-a.p);
  const bestPred = predArr[0] || null;
  const predHtml = predArr.length
    ? predArr.map(o=>`<span class=\"mg-pill ${bestPred && o.id===bestPred.id ? 'good' : ''}\">${escapeHtml(o.label)} ${pct(o.p,1)}<\/span>`).join("")
    : "";

  // v74: also expose next prediction in KPI area
  try{
    const kpi = $("mgNextPred");
    if(kpi) kpi.textContent = bestPred ? `${bestPred.label} ${pct(bestPred.p,1)}` : "—";
    const sub = $("mgNextPredSub");
    if(sub) sub.textContent = bestPred ? `최근 ${predN}회 기반` : "최근 결과 기반";
  }catch(e){}

  box.className = avoid ? "mg-risk mg-risk-bad" : tags.some(x=>x.cls==="warn") ? "mg-risk mg-risk-warn" : "mg-risk";
  box.innerHTML = `
    <div class=\"mg-risk-row\">
      <div>
        <div class=\"mg-risk-k\">AI 브리핑</div>
        <div class=\"mg-risk-v\"><b class=\"mg-em\">${score}</b> <span class=\"mg-muted\">(${level})</span></div>
      </div>
      <div>
        <div class=\"mg-risk-k\">세션 관리</div>
        <div class=\"mg-risk-v\">${escapeHtml(sesTxt)}</div>
      </div>
    </div>
    <div class=\"mg-risk-tags\">${tagHtml || '<span class="mg-pill">태그 없음</span>'}</div>
    <div class=\"mg-risk-tags\" style=\"margin-top:8px;\">
      <span class=\"mg-pill\">다음 예상</span>
      ${predHtml || '<span class="mg-pill">—</span>'}
      ${predHtml ? `<span class=\"mg-pill warn\">최근 ${predN}개 기반</span>` : ''}
    </div>
    <div class=\"mg-risk-brief\">
      <div>
        <div class=\"mg-risk-k\">주의</div>
        <ul class=\"mg-risk-ul\">${warnHtml}</ul>
      </div>
      <div>
        <div class=\"mg-risk-k\">추천</div>
        <ul class=\"mg-risk-ul\">${recoHtml}</ul>
      </div>
    </div>
  `;
}

function toNum(t){const e=Number(String(t).replace(/,/g,"").trim());return Number.isFinite(e)?e:NaN}function parseProbPct(t){const e=toNum(t);return Number.isFinite(e)?function clamp01(t){return Number.isFinite(t)?Math.max(0,Math.min(1,t)):NaN}(e/100):NaN}function calc(){const t=getMarket(getGame(s.game),s.market);let e=0;try{s.historyText&&(e=function computeFreqFromHistory(t,e){const n=String(t||"").replace(/[,|]+/g," ").replace(/[\r\n\t]+/g," ").split(" ").map(normalizeToken).filter(Boolean),s=new Map;e.outcomes.forEach(t=>{t.synonyms.forEach(e=>s.set(normalizeToken(e),t.id)),s.set(normalizeToken(t.label),t.id)});const o={};let a=0;n.forEach(t=>{const e=s.get(t);e&&(o[e]=(o[e]||0)+1,a++)});const i={};return e.outcomes.forEach(t=>{const e=o[t.id]||0;i[t.id]=a>0?e/a:NaN}),{total:a,counts:o,probs:i}}(s.historyText,t).total||0)}catch(t){e=0}const n=t.outcomes.map(t=>{const e=toNum(s.odds[t.id]),n=Number.isFinite(e)&&e>0?1/e:NaN,o=n,a=parseProbPct(s.probs[t.id]);return{id:t.id,label:t.label,odds:e,be:n,imp:o,userP:a}}),o=n.reduce((t,e)=>t+(Number.isFinite(e.imp)?e.imp:0),0),a=Number.isFinite(o)?o-1:NaN;return n.forEach(t=>{t.fairP=Number.isFinite(t.imp)&&o>0?t.imp/o:NaN,t.fairOdds=Number.isFinite(t.fairP)&&t.fairP>0?1/t.fairP:NaN;const e=t.userP;t.evPct=Number.isFinite(e)&&Number.isFinite(t.odds)?e*t.odds-1:NaN,t.evMoney=Number.isFinite(t.evPct)?toNum(s.stake)*t.evPct:NaN}),{outs:n,sumImp:o,margin:a,historyN:e}}function calcAndRender(){const t=calc(),e=t.sumImp,n=t.margin;$("mgSumP")&&($("mgSumP").textContent=Number.isFinite(e)?fmt(e,4):"—"),$("mgMargin")&&($("mgMargin").textContent=Number.isFinite(n)?pct(n,2):"—");const o=null!=s._lastHistoryN?s._lastHistoryN:t.historyN;$("mgN")&&($("mgN").textContent=s.historyText?String(o||0):"—"),$("mgMode")&&($("mgMode").textContent=`최근 ${s.recentN||6}개`);const a=$("mgOutBody");a&&(a.innerHTML=t.outs.map(t=>{const e=function verdict(t){return Number.isFinite(t)?t>=.02?{t:"추천",cls:"good"}:t>-.02?{t:"주의",cls:"warn"}:{t:"PASS",cls:"bad"}:{t:"—",cls:"neutral"}}(t.evPct),n=Number.isFinite(t.be)?pct(t.be,2):"—",s=Number.isFinite(t.fairP)?pct(t.fairP,2):"—",o=Number.isFinite(t.fairOdds)?fmt(t.fairOdds,3):"—",a=Number.isFinite(t.evPct)?pct(t.evPct,2):"—";return`\n          <tr>\n            <td><span class="mg-pill">${t.label}</span></td>\n            <td class="mg-right">${n}</td>\n            <td class="mg-right">${s}</td>\n            <td class="mg-right">${o}</td>\n            <td class="mg-right">${a}</td>\n            <td><span class="mg-tag ${e.cls}">${e.t}</span></td>\n          </tr>\n        `}).join(""))}function renderPickList(){const t=$("mgPickList");if(!t)return;const e=loadPicks();e.length?(t.innerHTML=e.slice(0,12).map(t=>{const e=new Date(t.ts||Date.now()),n=`${e.getFullYear()}-${String(e.getMonth()+1).padStart(2,"0")}-${String(e.getDate()).padStart(2,"0")} ${String(e.getHours()).padStart(2,"0")}:${String(e.getMinutes()).padStart(2,"0")}`,s=Number.isFinite(t.evPct)?pct(t.evPct,2):"—",o=Number.isFinite(t.margin)?pct(t.margin,2):"—",a=t.sample?String(t.sample):"—",i=t.memo?escapeHtml(t.memo):"",r=t.pickLabel?`${escapeHtml(t.pickLabel)} · EV ${escapeHtml(s)}`:"픽 정보 없음";return`\n        <div class="mg-pick-item" data-pick-id="${escapeHtml(t.id||"")}">\n          <div class="mg-pick-top">\n            <div>\n              <div class="mg-pick-title">${escapeHtml(t.gameTitle||"")} · ${escapeHtml(t.marketTitle||"")}</div>\n              <div class="mg-pick-meta">${escapeHtml(n)} · 표본 ${escapeHtml(a)} · 마진 ${escapeHtml(o)}</div>\n            </div>\n            <div class="mg-pick-actions">\n              <button class="mg-btn" type="button" data-act="del">삭제</button>\n            </div>\n          </div>\n          <div class="mg-pick-tags">\n            <span class="mg-pick-tag">${r}</span>\n            ${i?`<span class="mg-pick-tag">메모: ${i}</span>`:""}\n          </div>\n        </div>\n      `}).join(""),t.querySelectorAll('[data-act="del"]').forEach(t=>{t.onclick=()=>{const e=t.closest(".mg-pick-item"),n=e?.getAttribute("data-pick-id")||"";savePicks(loadPicks().filter(t=>String(t.id||"")!==String(n))),renderPickList(),toast("삭제 완료")}})):t.innerHTML='<div class="mg-note">저장된 픽이 없습니다. 분석 후 “현재 분석 저장”을 눌러보세요.</div>'}function bindPicks(){const t=$("mgPickSave");t&&(t.onclick=()=>{s.historyText&&String(s.historyText).trim()&&applyFreqNow(!0);const t=calc(),e=function bestPick(t){return t.filter(t=>Number.isFinite(t.evPct)).sort((t,e)=>e.evPct-t.evPct)[0]||null}(t.outs),n=getGame(s.game),o=getMarket(n,s.market),a=String($("mgPickMemo")?.value||"").trim(),i={id:`p_${Date.now()}_${Math.random().toString(16).slice(2)}`,ts:Date.now(),gameId:s.game,gameTitle:n.title,marketId:s.market,marketTitle:o.title,pickId:e?e.id:null,pickLabel:e?e.label:null,evPct:e?e.evPct:NaN,margin:t.margin,sample:s._lastHistoryN||0,recentN:s.recentN||6,memo:a},r=loadPicks();r.unshift(i),savePicks(r.slice(0,30)),$("mgPickMemo")&&($("mgPickMemo").value=""),renderPickList(),toast("픽 저장 완료")})}function debounce(t,e){let n=null;return function(){clearTimeout(n);const s=arguments;n=setTimeout(()=>t.apply(null,s),e)}}function normalizeToken(t){return String(t||"").trim().toLowerCase()}function escapeHtml(t){return String(t??"").replace(/[&<>"']/g,t=>({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"}[t]))}function mapTokenToOutcome(t,e){const n=normalizeToken(t);if(!n)return null;const s=e&&e.outcomes?e.outcomes:[];for(const t of s){if(normalizeToken(t.label)===n)return t.id;const e=Array.isArray(t.synonyms)?t.synonyms:[];for(const s of e)if(normalizeToken(s)===n)return t.id}return null}function labelOf(t,e){const n=e.outcomes.find(e=>e.id===t);return n?n.label:String(t||"")}function copyClip(t){const e=String(t||"" );try{if(navigator.clipboard&&navigator.clipboard.writeText)return navigator.clipboard.writeText(e)}catch(t){}try{const t=document.createElement("textarea");t.value=e,t.setAttribute("readonly",""),t.style.position="fixed",t.style.left="-9999px",document.body.appendChild(t),t.select(),document.execCommand("copy"),t.remove();return Promise.resolve()}catch(t){return Promise.reject(t)}}function toast(t){const e=$("mgToast");e&&(e.textContent=t,e.classList.add("on"),clearTimeout(toast._t),toast._t=setTimeout(()=>e.classList.remove("on"),1800))}function renderAll(){!function renderGameTabs(){const t=$("mgGameTabs");t&&(t.innerHTML=n.map(t=>`<button class="mg-chip ${t.id===s.game?"on":""}" type="button" data-game="${t.id}">${t.title}</button>`).join(""),t.querySelectorAll("button[data-game]").forEach(t=>{t.addEventListener("click",()=>{s.game=t.getAttribute("data-game");const e=getGame(s.game);s.market=e.markets[0].id,ensureMarketState(e.markets[0]),saveState(s),renderAll()})}))}(),function renderMarketSelect(){const t=getGame(s.game),e=$("mgMarket");e&&(e.innerHTML=t.markets.map(t=>`<option value="${t.id}">${t.title}</option>`).join(""),e.value=s.market,e.onchange=()=>{s.market=e.value,ensureMarketState(getMarket(t,s.market)),saveState(s),renderOutcomes(),renderQuickPanel(),String(s.historyText||"").trim()&&applyFreqNow(!0),calcAndRender(),updateRiskBox()})}(),renderOutcomes(),renderQuickPanel(),function bindStake(){const t=$("mgStake");t&&(t.value=s.stake??1e4,t.oninput=debounce(()=>{s.stake=toNum(t.value),saveState(s),calcAndRender(),updateRiskBox()},80))}(),function bindSessionControls(){const t=$("mgStopLoss"),e=$("mgStreakWarn");t&&(t.value=s.stopLoss?String(s.stopLoss):"",t.oninput=debounce(()=>{s.stopLoss=Math.max(0,toNum(t.value)||0),saveState(s),updateRiskBox()},120)),e&&(e.value=s.streakWarn?String(s.streakWarn):"",e.oninput=debounce(()=>{s.streakWarn=Math.max(0,parseInt(e.value,10)||0),saveState(s),updateRiskBox()},120))}(),function bindHistory(){const t=$("mgHistory"),e=$("mgApplyFreq");if(!t||!e)return;t.value=s.historyText||"";const n=$("mgRecentN");n&&(n.value=String(s.recentN||6),n.onchange=()=>{s.recentN=parseInt(n.value,10)||6,saveState(s),t.value.trim()&&applyFreqNow(!0)});const a=$("mgAutoApply");a&&(a.checked=!!s.autoApply,a.onchange=()=>{s.autoApply=!!a.checked,saveState(s)});t.oninput=debounce(()=>{s.historyText=t.value,saveState(s),s.autoApply&&String(s.historyText||"" ).trim()?applyFreqNow(!0):(calcAndRender(),updateRiskBox())},220),e.onclick=()=>{applyFreqNow(!1)};const o=$("mgClearHistory");o&&(o.onclick=()=>{s.historyText="",t.value="",getMarket(getGame(s.game),s.market).outcomes.forEach(t=>s.probs[t.id]=""),s._lastSeq=[],s._lastHistoryN=0,saveState(s),renderOutcomes(),calcAndRender(),updateRiskBox(),toast("히스토리 초기화")})}(),function bindActions(){const t=$("mgReset");t&&(t.onclick=()=>{s=defaultState(),saveState(s),renderAll()});const e=$("mgSave");e&&(e.onclick=()=>{saveState(s),toast("저장 완료")});const n=$("mgAnalyze");n&&(n.onclick=()=>{const t=s.historyText&&String(s.historyText).trim()?applyFreqNow(!0):null;calcAndRender();const e=$("mgProInsights");t&&t.total||!e||(e.innerHTML='<div class="mg-note">최근 결과를 붙여넣거나 “빠른 입력”을 사용하면 Pro 인사이트가 활성화됩니다.</div>'),updateRiskBox(),document.querySelector('[aria-label="결과"]')?.scrollIntoView({behavior:"smooth",block:"start"})});const c=$("mgCopySummary");c&&(c.onclick=()=>{try{s.historyText&&String(s.historyText).trim()&&applyFreqNow(!0);const t=calc(),e=function bestPick(t){return t.filter(t=>Number.isFinite(t.evPct)).sort((t,e)=>e.evPct-t.evPct)[0]||null}(t.outs),n=getGame(s.game),o=getMarket(n,s.market),a=s._lastHistoryN||t.historyN||0,i=`[88ST 미니게임 분석기] ${n.title} / ${o.title}\n최근 ${s.recentN||6} 기준 표본 ${a} · 마진 ${Number.isFinite(t.margin)?pct(t.margin,2):"—"}\n${e?`추천 ${e.label} · EV ${Number.isFinite(e.evPct)?pct(e.evPct,2):"—"} · 공정배당 ${Number.isFinite(e.fairOdds)?fmt(e.fairOdds,3):"—"}`:"추천: —"}\n배당: ${t.outs.map(t=>`${t.label} ${Number.isFinite(t.odds)?fmt(t.odds,3):"—"}`).join(" / ")}`;copyClip(i).then(()=>toast("요약 복사 완료")).catch(()=>toast("복사 실패"))}catch(t){toast("복사 실패")}});const o=$("mgFillFair");o&&(o.onclick=()=>{toast("이 버전은 공정확률 자동 채우기를 사용하지 않습니다. 히스토리 기반 확률을 사용하세요.")})}(),calcAndRender(),bindPicks(),renderPickList(),updateRiskBox(),window.__MG_INIT_DONE=!0}document.addEventListener("DOMContentLoaded",renderAll)}();